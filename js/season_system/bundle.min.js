/*!
 * 合并的 JavaScript 包
 * 生成时间: 2026/2/23 16:00:57
 * 文件数量: 13
 * 依赖顺序:
 * 1. ../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/spring/floawer.js
 * 2. ../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/winter/day_effect.js
 * 3. ../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/winter/light_effect.js
 * 4. ../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/winter/night_effect.js
 * 5. ../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/winter/star_effect.js
 * 6. ../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/effect_scheduler/priority_manager.js
 * 7. ../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/local_time_parser.js
 * 8. ../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/effect_scheduler/effect_scheduler.js
 * 9. ../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/season_determination.js
 * 10. ../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/time_period_identifier.js
 * 11. ../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/time_detection.js
 * 12. ../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_manager.js
 * 13. ../../../D:/WorkSpace/IIS/static/source/js/season_system/manager.js
 */

(function() {
  'use strict';

  // 模块缓存
  var __modules = {};
  var __cache = {};

  // require 函数
  function __require(moduleId) {
    if (__cache[moduleId]) {
      return __cache[moduleId].exports;
    }
    
    var module = __cache[moduleId] = {
      exports: {}
    };
    
    __modules[moduleId].call(module.exports, module, module.exports, __require);
    
    return module.exports;
  }

  // 模块定义

  // 模块: ../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/spring/floawer
  __modules["../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/spring/floawer"] = function(module, exports, __require) {
    /**
     * 飘花效果
     * 春季特有的视觉效果
     */
    
    class FlowerEffect {
      constructor() {
        this.petals = [];
        this.maxPetals = 50;
        this.isRunning = false;
      }
    
      /**
       * 创建花瓣元素
       * @param {Object} config - 花瓣配置
       * @returns {HTMLElement} 花瓣元素
       */
      createPetal(config = {}) {
        const petal = document.createElement('div');
        
        // 设置花瓣样式
        const size = config.size || Math.random() * 10 + 5;
        const left = Math.random() * 100;
        const duration = config.duration || Math.random() * 10 + 10;
        const delay = Math.random() * 5;
        const opacity = Math.random() * 0.8 + 0.2;
        const rotation = Math.random() * 360;
        const rotationSpeed = Math.random() * 10 - 5;
        
        petal.style.position = 'fixed';
        petal.style.top = '-20px';
        petal.style.left = `${left}%`;
        petal.style.width = `${size}px`;
        petal.style.height = `${size}px`;
        petal.style.opacity = opacity;
        petal.style.pointerEvents = 'none';
        petal.style.zIndex = '9999';
        petal.style.borderRadius = '150% 0 150% 0';
        petal.style.backgroundColor = config.color || '#ffb6c1';
        petal.style.transform = `rotate(${rotation}deg)`;
        petal.style.animation = `falling ${duration}s linear infinite`;
        petal.style.animationDelay = `${delay}s`;
        
        // 添加到DOM
        document.body.appendChild(petal);
        this.petals.push(petal);
        
        return petal;
      }
    
      /**
       * 创建飘落动画
       */
      createAnimation() {
        // 检查是否已经存在动画
        if (!document.getElementById('flower-animation-style')) {
          const style = document.createElement('style');
          style.id = 'flower-animation-style';
          style.textContent = `
            @keyframes falling {
              0% {
                transform: translateY(-20px) rotate(0deg);
                opacity: 0.8;
              }
              10% {
                opacity: 1;
              }
              90% {
                opacity: 1;
              }
              100% {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
              }
            }
          `;
          document.head.appendChild(style);
        }
      }
    
      /**
       * 启动飘花效果
       * @param {Object} config - 效果配置
       */
      start(config = {}) {
        if (this.isRunning) return;
        
        this.isRunning = true;
        this.createAnimation();
        
        // 创建花瓣
        const maxPetals = config.maxPetals || this.maxPetals;
        
        for (let i = 0; i < maxPetals; i++) {
          setTimeout(() => {
            if (this.isRunning) {
              this.createPetal(config);
            }
          }, i * 200);
        }
        
        console.log('飘花效果已启动');
      }
    
      /**
       * 停止飘花效果
       */
      stop() {
        this.isRunning = false;
        
        // 移除所有花瓣
        this.petals.forEach(petal => {
          if (petal.parentNode) {
            petal.parentNode.removeChild(petal);
          }
        });
        
        this.petals = [];
        
        console.log('飘花效果已停止');
      }
    
      /**
       * 重置飘花效果
       * @param {Object} config - 效果配置
       */
      reset(config = {}) {
        this.stop();
        this.start(config);
      }
    
      /**
       * 调整花瓣数量
       * @param {number} count - 花瓣数量
       */
      setPetalCount(count) {
        this.maxPetals = count;
        if (this.isRunning) {
          this.reset();
        }
      }
    }
    
    // 导出单例实例
    const flowerEffect = new FlowerEffect();
    exports.default = flowerEffect;
    exports.FlowerEffect = FlowerEffect;;
    
    // 注册效果处理器到效果调度器
    if (typeof window !== 'undefined') {
      // 在浏览器环境中注册
      window.addEventListener('DOMContentLoaded', () => {
        if (window.Bundle && window.Bundle.effectScheduler) {
          const effectScheduler = window.Bundle.effectScheduler;
          
          // 注册飘花效果处理器
          effectScheduler.registerEffectHandler('flower', (config) => {
            return new Promise((resolve) => {
              flowerEffect.start(config);
              setTimeout(resolve, 1000); // 延迟1秒后 resolve，让效果有时间启动
            });
          });
          
          // 添加飘花效果到春季效果库
          effectScheduler.addEffect(
            'spring_flower',
            { type: 'flower' },
            50, // 比重
            'spring' // 季节
          );
          
          console.log('飘花效果已注册到效果库');
        }
      });
    }
    
  };

  // 模块: ../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/winter/day_effect
  __modules["../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/winter/day_effect"] = function(module, exports, __require) {
    /**
     * 冬季白天效果
     * 为冬季白天添加太阳、阳光、雪花、雪人和观雪小人效果
     */
    
    class WinterDayEffect {
      constructor() {
        this.elements = [];
        this.isRunning = false;
      }
    
      /**
       * 创建太阳元素
       * @returns {HTMLElement} 太阳元素
       */
      createSun() {
        const sun = document.createElement('div');
        
        // 设置太阳样式
        sun.style.position = 'fixed';
        sun.style.top = '60px';
        sun.style.right = '40px';
        sun.style.width = '40px';
        sun.style.height = '40px';
        sun.style.backgroundColor = '#fffacd';
        sun.style.borderRadius = '50%';
        sun.style.boxShadow = '0 0 40px rgba(255, 255, 255, 0.9), 0 0 80px rgba(255, 250, 205, 0.7), 0 0 120px rgba(255, 248, 220, 0.5), 0 0 160px rgba(255, 245, 238, 0.3)';
        sun.style.zIndex = '9995';
        sun.style.animation = 'sunGlow 4s ease-in-out infinite alternate';
        
        document.body.appendChild(sun);
        this.elements.push(sun);
        
        return sun;
      }
    
    
      /**
       * 创建雪花元素
       * @param {Object} config - 雪花配置
       * @returns {HTMLElement} 雪花元素
       */
      createSnowflake(config = {}) {
        const snowflake = document.createElement('div');
        snowflake.className = 'snowflake';
        
        // 设置雪花样式
        const size = config.size || Math.random() * 12 + 8;
        const left = Math.random() * 100;
        const duration = config.duration || Math.random() * 10 + 8;
        const delay = Math.random() * 5;
        const opacity = Math.random() * 0.7 + 0.3;
        
        snowflake.style.position = 'fixed';
        snowflake.style.top = '-20px';
        snowflake.style.left = `${left}%`;
        snowflake.style.width = `${size}px`;
        snowflake.style.height = `${size}px`;
        snowflake.style.opacity = opacity;
        snowflake.style.pointerEvents = 'none';
        snowflake.style.zIndex = '9996';
        snowflake.style.animation = `daySnowfall ${duration}s linear infinite`;
        snowflake.style.animationDelay = `${delay}s`;
        
        // 创建雪花形状
        const snowflakeInner = document.createElement('div');
        snowflakeInner.style.width = '100%';
        snowflakeInner.style.height = '100%';
        snowflakeInner.style.position = 'relative';
        snowflakeInner.style.animation = 'snowflakeRotate 3s linear infinite';
        
        // 创建六个花瓣
        for (let i = 0; i < 6; i++) {
          const petal = document.createElement('div');
          petal.style.position = 'absolute';
          petal.style.width = '40%';
          petal.style.height = '40%';
          petal.style.backgroundColor = '#ffffff';
          petal.style.borderRadius = '50%';
          petal.style.left = '50%';
          petal.style.top = '50%';
          petal.style.transform = `translate(-50%, -50%) rotate(${i * 60}deg)`;
          petal.style.boxShadow = '0 0 3px rgba(255, 255, 255, 0.8)';
          snowflakeInner.appendChild(petal);
          
          // 创建花瓣尖端
          const petalTip = document.createElement('div');
          petalTip.style.position = 'absolute';
          petalTip.style.width = '60%';
          petalTip.style.height = '60%';
          petalTip.style.backgroundColor = '#ffffff';
          petalTip.style.borderRadius = '50%';
          petalTip.style.left = '50%';
          petalTip.style.top = '-20%';
          petalTip.style.transform = 'translate(-50%, -50%)';
          petal.appendChild(petalTip);
        }
        
        snowflake.appendChild(snowflakeInner);
        document.body.appendChild(snowflake);
        this.elements.push(snowflake);
        
        return snowflake;
      }
    
    
    
    
      /**
       * 创建动画
       */
      createAnimation() {
        // 检查是否已经存在动画
        if (!document.getElementById('winter-day-animation')) {
          const style = document.createElement('style');
          style.id = 'winter-day-animation';
          style.textContent = `
            @keyframes sunGlow {
              0% {
                box-shadow: 0 0 60px rgba(255, 255, 255, 0.8), 0 0 120px rgba(255, 250, 205, 0.6), 0 0 180px rgba(255, 248, 220, 0.4), 0 0 240px rgba(255, 245, 238, 0.2);
              }
              100% {
                box-shadow: 0 0 100px rgba(255, 255, 255, 1), 0 0 200px rgba(255, 250, 205, 0.8), 0 0 300px rgba(255, 248, 220, 0.6), 0 0 400px rgba(255, 245, 238, 0.4);
              }
            }
            
            @keyframes daySnowfall {
              0% {
                transform: translateY(-20px) translateX(0) rotate(0deg);
                opacity: 0.3;
              }
              10% {
                opacity: 0.7;
              }
              25% {
                transform: translateY(25vh) translateX(30px) rotate(90deg);
                opacity: 0.7;
              }
              50% {
                transform: translateY(50vh) translateX(-20px) rotate(180deg);
                opacity: 0.7;
              }
              75% {
                transform: translateY(75vh) translateX(40px) rotate(270deg);
                opacity: 0.7;
              }
              90% {
                opacity: 0.7;
              }
              100% {
                transform: translateY(100vh) translateX(-30px) rotate(360deg);
                opacity: 0.3;
              }
            }
            
            @keyframes snowflakeRotate {
              0% {
                transform: rotate(0deg);
              }
              100% {
                transform: rotate(360deg);
              }
            }
          `;
          document.head.appendChild(style);
        }
      }
    
      /**
       * 启动冬季白天效果
       * @param {Object} config - 效果配置
       */
      start(config = {}) {
        if (this.isRunning) {
          console.log('冬季白天效果已经在运行中');
          return;
        }
        
        console.log('开始执行冬季白天效果...');
        console.log('效果配置:', config);
        
        this.isRunning = true;
        this.createAnimation();
        
        // 创建太阳
        this.createSun();
        
        // 创建雪花
        const snowflakeCount = config.snowflakeCount || 30;
        console.log('生成雪花数量:', snowflakeCount);
        
        for (let i = 0; i < snowflakeCount; i++) {
          setTimeout(() => {
            if (this.isRunning) {
              this.createSnowflake(config);
            }
          }, i * 50);
        }
        
        console.log('冬季白天效果执行成功！太阳和雪花正在显示...');
      }
    
      /**
       * 停止冬季白天效果
       */
      stop() {
        this.isRunning = false;
        
        // 移除所有元素
        this.elements.forEach(element => {
          if (element.parentNode) {
            element.parentNode.removeChild(element);
          }
        });
        
        this.elements = [];
        
        console.log('冬季白天效果已停止');
      }
    
      /**
       * 重置冬季白天效果
       * @param {Object} config - 效果配置
       */
      reset(config = {}) {
        this.stop();
        this.start(config);
      }
    }
    
    // 导出单例实例
    const winterDayEffect = new WinterDayEffect();
    exports.default = winterDayEffect;
    exports.WinterDayEffect = WinterDayEffect;;
    
    // 在浏览器环境中挂载到 window 对象
    if (typeof window !== 'undefined') {
      // 挂载 winterDayEffect 到 window 对象
      window.winterDayEffect = winterDayEffect;
      console.log('冬季白天效果已挂载到 window 对象');
      
      // 在浏览器环境中注册
      window.addEventListener('DOMContentLoaded', () => {
        if (window.Bundle && window.Bundle.effectScheduler) {
          const effectScheduler = window.Bundle.effectScheduler;
          
          // 注册冬季白天效果处理器
          effectScheduler.registerEffectHandler('winter_day', (config) => {
            return new Promise((resolve) => {
              winterDayEffect.start(config);
              setTimeout(resolve, 1000); // 延迟1秒后 resolve，让效果有时间启动
            });
          });
          
          // 添加冬季白天效果到冬季效果库（对应上午、中午、下午时段）
          effectScheduler.addEffect(
            'winter_morning_effect',
            { type: 'winter_day' },
            60, // 比重
            'winter', // 季节
            'morning' // 时段
          );
          
          effectScheduler.addEffect(
            'winter_noon_effect',
            { type: 'winter_day' },
            60, // 比重
            'winter', // 季节
            'noon' // 时段
          );
          
          effectScheduler.addEffect(
            'winter_afternoon_effect',
            { type: 'winter_day' },
            60, // 比重
            'winter', // 季节
            'afternoon' // 时段
          );
    
          effectScheduler.addEffect(
            'winter_evening_effect',
            { type: 'winter_day' },
            60, // 比重
            'winter', // 季节
            'night' // 时段
          );
          
          console.log('冬季白天效果已注册到效果库');
        }
      });
    }
    
  };

  // 模块: ../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/winter/light_effect
  __modules["../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/winter/light_effect"] = function(module, exports, __require) {
    /**
     * 冬季夜晚孔明灯效果
     * 为冬季夜晚添加向上飘动的孔明灯效果
     */
    
    class LightEffect {
      constructor() {
        this.lights = [];
        this.maxLights = 30;
        this.isRunning = false;
      }
    
      /**
       * 创建孔明灯元素
       * @param {Object} config - 孔明灯配置
       * @returns {HTMLElement} 孔明灯元素
       */
      /**
       * 获取随机祝福文字
       * @returns {string} 两字祝福
       */
      getRandomBlessing() {
        const blessings = [
          '平安', '幸福', '健康', '快乐',
          '吉祥', '如意', '发财', '顺利',
          '成功', '美满', '和谐', '安康',
          '幸运', '繁荣', 
        ];
        return blessings[Math.floor(Math.random() * blessings.length)];
      }
    
      createLight(config = {}) {
        // 创建孔明灯容器
        const lightContainer = document.createElement('div');
        
        // 设置孔明灯容器样式
        const size = Math.random() * 40 + 20;
        const left = Math.random() * 100;
        const top = '100%'; // 从屏幕底部开始
        const opacity = Math.random() * 0.5 + 0.3; // 透明度范围 0.3-0.8
        const floatDuration = Math.random() * 20 + 15;
        const delay = Math.random() * 5;
        
        lightContainer.style.position = 'fixed';
        lightContainer.style.top = top;
        lightContainer.style.left = `${left}%`;
        lightContainer.style.width = `${size}px`;
        lightContainer.style.height = `${size}px`;
        lightContainer.style.opacity = opacity;
        lightContainer.style.pointerEvents = 'none';
        lightContainer.style.zIndex = '9997';
        lightContainer.style.backgroundColor = 'transparent';
        lightContainer.style.border = 'none';
        lightContainer.style.animation = `float ${floatDuration}s linear infinite`;
        lightContainer.style.animationDelay = `${delay}s`;
        
        // 使用img元素直接作为孔明灯
        const img = document.createElement('img');
        img.src = '/img/kmd.png';
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.display = 'block';
        img.style.backgroundColor = '';
        img.style.border = 'none';
        img.style.outline = 'none';
        img.style.padding = '0';
        img.style.margin = '0';
        img.style.filter = 'drop-shadow(0 0 6px rgba(255, 255, 200, 0.7))';
        img.style.animation = `flicker ${Math.random() * 4 + 3}s ease-in-out infinite alternate`;
        lightContainer.appendChild(img);
        
        // 创建祝福文字
        const blessing = document.createElement('div');
        const blessingText = this.getRandomBlessing();
        blessing.textContent = blessingText;
        blessing.style.position = 'absolute';
        blessing.style.top = '50%';
        blessing.style.left = '50%';
        blessing.style.transform = 'translate(-50%, -50%)';
        blessing.style.fontSize = `${size * 0.2}px`;
        blessing.style.color = '#ffd700';
        blessing.style.fontWeight = 'bold';
        blessing.style.textShadow = '1px 1px 2px rgba(0, 0, 0, 0.8)';
        blessing.style.textAlign = 'center';
        blessing.style.pointerEvents = 'none';
        lightContainer.appendChild(blessing);
        
        // 创建下方灯光
        const bottomLight = document.createElement('div');
        const lightSize = size * 0.25;
        bottomLight.style.position = 'absolute';
        bottomLight.style.bottom = `-${lightSize * 0.6}px`;
        bottomLight.style.left = '50%';
        bottomLight.style.transform = 'translateX(-50%)';
        bottomLight.style.width = `${lightSize}px`;
        bottomLight.style.height = `${lightSize}px`;
        bottomLight.style.backgroundColor = 'rgba(255, 215, 0, 0.7)';
        bottomLight.style.borderRadius = '50%';
        bottomLight.style.boxShadow = '0 0 8px rgba(255, 215, 0, 0.8), 0 0 15px rgba(255, 215, 0, 0.5)';
        bottomLight.style.animation = `lightFlicker ${Math.random() * 3 + 2}s ease-in-out infinite alternate`;
        bottomLight.style.pointerEvents = 'none';
        lightContainer.appendChild(bottomLight);
        
        // 添加到DOM
        document.body.appendChild(lightContainer);
        this.lights.push(lightContainer);
        
        return lightContainer;
      }
    
    
    
      /**
       * 创建闪烁和飘动动画
       */
      createAnimation() {
        // 检查是否已经存在动画
        if (!document.getElementById('light-flicker-animation')) {
          const style = document.createElement('style');
          style.id = 'light-flicker-animation';
          style.textContent = `
            @keyframes flicker {
              0% {
                opacity: 0.6;
                transform: scale(0.95);
              }
              100% {
                opacity: 1;
                transform: scale(1.05);
              }
            }
            
            @keyframes lightFlicker {
              0% {
                opacity: 0.6;
                transform: scale(0.9);
                box-shadow: 0 0 8px rgba(255, 215, 0, 0.8), 0 0 15px rgba(255, 215, 0, 0.5);
              }
              100% {
                opacity: 1;
                transform: scale(1.1);
                box-shadow: 0 0 12px rgba(255, 215, 0, 1), 0 0 25px rgba(255, 215, 0, 0.8);
              }
            }
            
            @keyframes float {
              0% {
                transform: translateY(0) translateX(0) rotate(0deg);
                opacity: 0.5;
              }
              25% {
                transform: translateY(-25vh) translateX(8px) rotate(1deg);
                opacity: 0.7;
              }
              50% {
                transform: translateY(-50vh) translateX(-8px) rotate(-1deg);
                opacity: 0.8;
              }
              75% {
                transform: translateY(-75vh) translateX(4px) rotate(0.5deg);
                opacity: 0.7;
              }
              100% {
                transform: translateY(-100vh) translateX(-4px) rotate(0deg);
                opacity: 0.4;
              }
            }
          `;
          document.head.appendChild(style);
        }
      }
    
      /**
       * 启动孔明灯效果
       * @param {Object} config - 效果配置
       */
      start(config = {}) {
        if (this.isRunning) {
          console.log('孔明灯效果已经在运行中');
          return;
        }
        
        console.log('开始执行孔明灯效果...');
        console.log('效果配置:', config);
        
        this.isRunning = true;
        this.createAnimation();
        
        // 创建孔明灯
        const maxLights = config.maxLights || this.maxLights;
        console.log('生成孔明灯数量:', maxLights);
        
        for (let i = 0; i < maxLights; i++) {
          setTimeout(() => {
            if (this.isRunning) {
              this.createLight(config);
            }
          }, i * 100);
        }
        
        console.log('孔明灯效果执行成功！孔明灯正在飘动...');
      }
    
      /**
       * 停止孔明灯效果
       */
      stop() {
        this.isRunning = false;
        
        // 移除所有孔明灯
        this.lights.forEach(light => {
          if (light.parentNode) {
            light.parentNode.removeChild(light);
          }
        });
        
        this.lights = [];
        
        console.log('孔明灯效果已停止');
      }
    
      /**
       * 重置孔明灯效果
       * @param {Object} config - 效果配置
       */
      reset(config = {}) {
        this.stop();
        this.start(config);
      }
    
      /**
       * 调整孔明灯数量
       * @param {number} count - 孔明灯数量
       */
      setLightCount(count) {
        this.maxLights = count;
        if (this.isRunning) {
          this.reset();
        }
      }
    }
    
    // 导出单例实例
    const lightEffect = new LightEffect();
    exports.default = lightEffect;
    exports.LightEffect = LightEffect;;
    
    // 在浏览器环境中挂载到 window 对象
    if (typeof window !== 'undefined') {
      // 挂载 lightEffect 到 window 对象
      window.lightEffect = lightEffect;
      console.log('孔明灯效果已挂载到 window 对象');
      
      // 在浏览器环境中注册
      window.addEventListener('DOMContentLoaded', () => {
        if (window.Bundle && window.Bundle.effectScheduler) {
          const effectScheduler = window.Bundle.effectScheduler;
          
          // 注册孔明灯效果处理器
          effectScheduler.registerEffectHandler('flying_lights', (config) => {
            return new Promise((resolve) => {
              lightEffect.start(config);
              setTimeout(resolve, 500); // 延迟0.5秒后 resolve，让效果有时间启动
            });
          });
          
          // 添加孔明灯效果到冬季效果库
          effectScheduler.addEffect(
            'winter_flying_light_effect',
            { type: 'flying_lights' },
            60, // 比重
            'winter', // 季节
            'evening' // 时段
          );
          
          console.log('孔明灯效果已注册到效果库');
        }
      });
    }
    
  };

  // 模块: ../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/winter/night_effect
  __modules["../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/winter/night_effect"] = function(module, exports, __require) {
    /**
     * 冬季晚上效果
     * 冬季特有的视觉效果
     */
    
    class WinterNightEffect {
      constructor() {
        this.snowflakes = [];
        this.maxSnowflakes = 100;
        this.isRunning = false;
      }
    
      /**
       * 创建雪花元素
       * @param {Object} config - 雪花配置
       * @returns {HTMLElement} 雪花元素
       */
      createSnowflake(config = {}) {
        const snowflake = document.createElement('div');
        
        // 设置雪花样式
        const size = config.size || Math.random() * 8 + 2;
        const left = Math.random() * 100;
        const duration = config.duration || Math.random() * 15 + 10;
        const delay = Math.random() * 5;
        const opacity = Math.random() * 0.8 + 0.2;
        const rotation = Math.random() * 360;
        const rotationSpeed = Math.random() * 10 - 5;
        
        snowflake.style.position = 'fixed';
        snowflake.style.top = '-20px';
        snowflake.style.left = `${left}%`;
        snowflake.style.width = `${size}px`;
        snowflake.style.height = `${size}px`;
        snowflake.style.opacity = opacity;
        snowflake.style.pointerEvents = 'none';
        snowflake.style.zIndex = '9999';
        snowflake.style.borderRadius = '50%';
        snowflake.style.backgroundColor = config.color || '#ffffff';
        snowflake.style.boxShadow = '0 0 5px rgba(255, 255, 255, 0.8)';
        snowflake.style.transform = `rotate(${rotation}deg)`;
        snowflake.style.animation = `snowfall ${duration}s linear infinite`;
        snowflake.style.animationDelay = `${delay}s`;
        
        // 添加到DOM
        document.body.appendChild(snowflake);
        this.snowflakes.push(snowflake);
        
        return snowflake;
      }
    
      /**
       * 创建飘落动画
       */
      createAnimation() {
        // 检查是否已经存在动画
        if (!document.getElementById('snowfall-animation-style')) {
          const style = document.createElement('style');
          style.id = 'snowfall-animation-style';
          style.textContent = `
            @keyframes snowfall {
              0% {
                transform: translateY(-20px) rotate(0deg);
                opacity: 0.8;
              }
              10% {
                opacity: 1;
              }
              90% {
                opacity: 1;
              }
              100% {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
              }
            }
          `;
          document.head.appendChild(style);
        }
      }
    
      /**
       * 启动冬季晚上效果
       * @param {Object} config - 效果配置
       */
      start(config = {}) {
        if (this.isRunning) {
          console.log('冬季晚上效果已经在运行中');
          return;
        }
        
        console.log('开始执行冬季晚上效果...');
        console.log('效果配置:', config);
        
        this.isRunning = true;
        this.createAnimation();
        
        // 创建雪花
        const maxSnowflakes = config.maxSnowflakes || this.maxSnowflakes;
        console.log('生成雪花数量:', maxSnowflakes);
        
        for (let i = 0; i < maxSnowflakes; i++) {
          setTimeout(() => {
            if (this.isRunning) {
              this.createSnowflake(config);
            }
          }, i * 100);
        }
        
        console.log('冬季晚上效果执行成功！雪花正在飘落...');
      }
    
      /**
       * 停止冬季晚上效果
       */
      stop() {
        this.isRunning = false;
        
        // 移除所有雪花
        this.snowflakes.forEach(snowflake => {
          if (snowflake.parentNode) {
            snowflake.parentNode.removeChild(snowflake);
          }
        });
        
        this.snowflakes = [];
        
        console.log('冬季晚上效果已停止');
      }
    
      /**
       * 重置冬季晚上效果
       * @param {Object} config - 效果配置
       */
      reset(config = {}) {
        this.stop();
        this.start(config);
      }
    
      /**
       * 调整雪花数量
       * @param {number} count - 雪花数量
       */
      setSnowflakeCount(count) {
        this.maxSnowflakes = count;
        if (this.isRunning) {
          this.reset();
        }
      }
    }
    
    // 导出单例实例
    const winterNightEffect = new WinterNightEffect();
    exports.default = winterNightEffect;
    exports.WinterNightEffect = WinterNightEffect;;
    
    // 在浏览器环境中挂载到 window 对象
    if (typeof window !== 'undefined') {
      // 挂载 winterNightEffect 到 window 对象
      window.winterNightEffect = winterNightEffect;
      console.log('冬季晚上效果已挂载到 window 对象');
      
      // 在浏览器环境中注册
      window.addEventListener('DOMContentLoaded', () => {
        if (window.Bundle && window.Bundle.effectScheduler) {
          const effectScheduler = window.Bundle.effectScheduler;
          
          // 注册冬季晚上效果处理器
          effectScheduler.registerEffectHandler('winter_night', (config) => {
            return new Promise((resolve) => {
              winterNightEffect.start(config);
              setTimeout(resolve, 1000); // 延迟1秒后 resolve，让效果有时间启动
            });
          });
          
          // 添加冬季晚上效果到冬季效果库
          effectScheduler.addEffect(
            'winter_night_effect',
            { type: 'winter_night' },
            10, // 比重
            'winter', // 季节
            'night' // 时段
          );
          
          console.log('冬季晚上效果已注册到效果库');
        }
      });
    }
    
  };

  // 模块: ../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/winter/star_effect
  __modules["../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/winter/star_effect"] = function(module, exports, __require) {
    /**
     * 冬季夜晚星光闪烁效果
     * 为冬季夜晚添加安静的星光闪烁效果
     */
    
    class StarEffect {
      constructor() {
        this.stars = [];
        this.maxStars = 50;
        this.isRunning = false;
      }
    
      /**
       * 创建星星元素
       * @param {Object} config - 星星配置
       * @returns {HTMLElement} 星星元素
       */
      createStar(config = {}) {
        const star = document.createElement('div');
        
        // 设置星星样式
        const size = config.size || Math.random() * 3 + 1;
        const left = Math.random() * 100;
        const top = Math.random() * 100;
        const opacity = Math.random() * 0.8 + 0.2;
        const duration = Math.random() * 3 + 2;
        
        star.style.position = 'fixed';
        star.style.top = `${top}%`;
        star.style.left = `${left}%`;
        star.style.width = `${size}px`;
        star.style.height = `${size}px`;
        star.style.opacity = opacity;
        star.style.pointerEvents = 'none';
        star.style.zIndex = '9998';
        star.style.borderRadius = '50%';
        star.style.backgroundColor = config.color || '#ffffff';
        star.style.boxShadow = '0 0 6px rgba(255, 255, 255, 0.8)';
        star.style.animation = `twinkle ${duration}s ease-in-out infinite alternate`;
        
        // 添加到DOM
        document.body.appendChild(star);
        this.stars.push(star);
        
        return star;
      }
    
      /**
       * 创建闪烁动画
       */
      createAnimation() {
        // 检查是否已经存在动画
        if (!document.getElementById('star-twinkle-animation')) {
          const style = document.createElement('style');
          style.id = 'star-twinkle-animation';
          style.textContent = `
            @keyframes twinkle {
              0% {
                opacity: 0.2;
                transform: scale(0.8);
              }
              100% {
                opacity: 1;
                transform: scale(1.2);
              }
            }
          `;
          document.head.appendChild(style);
        }
      }
    
      /**
       * 启动星光闪烁效果
       * @param {Object} config - 效果配置
       */
      start(config = {}) {
        if (this.isRunning) {
          console.log('星光闪烁效果已经在运行中');
          return;
        }
        
        console.log('开始执行星光闪烁效果...');
        console.log('效果配置:', config);
        
        this.isRunning = true;
        this.createAnimation();
        
        // 创建星星
        const maxStars = config.maxStars || this.maxStars;
        console.log('生成星星数量:', maxStars);
        
        for (let i = 0; i < maxStars; i++) {
          setTimeout(() => {
            if (this.isRunning) {
              this.createStar(config);
            }
          }, i * 50);
        }
        
        console.log('星光闪烁效果执行成功！星星正在闪烁...');
      }
    
      /**
       * 停止星光闪烁效果
       */
      stop() {
        this.isRunning = false;
        
        // 移除所有星星
        this.stars.forEach(star => {
          if (star.parentNode) {
            star.parentNode.removeChild(star);
          }
        });
        
        this.stars = [];
        
        console.log('星光闪烁效果已停止');
      }
    
      /**
       * 重置星光闪烁效果
       * @param {Object} config - 效果配置
       */
      reset(config = {}) {
        this.stop();
        this.start(config);
      }
    
      /**
       * 调整星星数量
       * @param {number} count - 星星数量
       */
      setStarCount(count) {
        this.maxStars = count;
        if (this.isRunning) {
          this.reset();
        }
      }
    }
    
    // 导出单例实例
    const starEffect = new StarEffect();
    exports.default = starEffect;
    exports.StarEffect = StarEffect;;
    
    // 在浏览器环境中挂载到 window 对象
    if (typeof window !== 'undefined') {
      // 挂载 starEffect 到 window 对象
      window.starEffect = starEffect;
      console.log('星光闪烁效果已挂载到 window 对象');
      
      // 在浏览器环境中注册
      window.addEventListener('DOMContentLoaded', () => {
        if (window.Bundle && window.Bundle.effectScheduler) {
          const effectScheduler = window.Bundle.effectScheduler;
          
          // 注册星光闪烁效果处理器
          effectScheduler.registerEffectHandler('star_twinkle', (config) => {
            return new Promise((resolve) => {
              starEffect.start(config);
              setTimeout(resolve, 500); // 延迟0.5秒后 resolve，让效果有时间启动
            });
          });
          
          // 添加星光闪烁效果到冬季效果库
          effectScheduler.addEffect(
            'winter_star_effect',
            { type: 'star_twinkle' },
            10, // 比重
            'winter', // 季节
            'night' // 时段
          );
          
          console.log('星光闪烁效果已注册到效果库');
        }
      });
    }
    
  };

  // 模块: ../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/effect_scheduler/priority_manager
  __modules["../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/effect_scheduler/priority_manager"] = function(module, exports, __require) {
    /**
     * 效果比重管理器
     * 用于管理四季系统中各种效果的比重
     */
    class WeightManager {
      constructor() {
        this.effects = new Map();
        this.seasonEffects = new Map();
        this.timePeriodEffects = new Map();
        this.seasonTimePeriodEffects = new Map();
        this.originalWeights = new Map(); // 记录每个效果的原始比重
        this.lastResetDate = null; // 上次重置日期
        this.defaultWeight = 30;
      }
    
      /**
       * 添加效果
       * @param {string} effectId - 效果ID
       * @param {Object} effectConfig - 效果配置
       * @param {number} weight - 比重 (0-100，数字越大比重越高)
       * @param {string} season - 季节
       * @param {string} timePeriod - 时段
       */
      addEffect(effectId, effectConfig, weight = this.defaultWeight, season = null, timePeriod = null) {
        if (typeof weight !== 'number' || weight < 0 || weight > 100) {
          throw new Error('比重必须是0-100之间的数字');
        }
    
        const effect = {
          id: effectId,
          config: effectConfig,
          weight: weight,
          season: season,
          timePeriod: timePeriod
        };
    
        this.effects.set(effectId, effect);
        this.originalWeights.set(effectId, weight); // 存储原始比重
    
        // 按季节分组
        if (season) {
          if (!this.seasonEffects.has(season)) {
            this.seasonEffects.set(season, new Map());
          }
          this.seasonEffects.get(season).set(effectId, effect);
        }
    
        // 按时段分组
        if (timePeriod) {
          if (!this.timePeriodEffects.has(timePeriod)) {
            this.timePeriodEffects.set(timePeriod, new Map());
          }
          this.timePeriodEffects.get(timePeriod).set(effectId, effect);
        }
    
        // 按季节+时段分组
        if (season && timePeriod) {
          const key = `${season}_${timePeriod}`;
          if (!this.seasonTimePeriodEffects.has(key)) {
            this.seasonTimePeriodEffects.set(key, new Map());
          }
          this.seasonTimePeriodEffects.get(key).set(effectId, effect);
        }
    
        return this;
      }
    
      /**
       * 移除效果
       * @param {string} effectId - 效果ID
       */
      removeEffect(effectId) {
        if (this.effects.has(effectId)) {
          const effect = this.effects.get(effectId);
          // 从季节分组中移除
          if (effect.season && this.seasonEffects.has(effect.season)) {
            this.seasonEffects.get(effect.season).delete(effectId);
            if (this.seasonEffects.get(effect.season).size === 0) {
              this.seasonEffects.delete(effect.season);
            }
          }
          // 从时段分组中移除
          if (effect.timePeriod && this.timePeriodEffects.has(effect.timePeriod)) {
            this.timePeriodEffects.get(effect.timePeriod).delete(effectId);
            if (this.timePeriodEffects.get(effect.timePeriod).size === 0) {
              this.timePeriodEffects.delete(effect.timePeriod);
            }
          }
          // 从季节+时段分组中移除
          if (effect.season && effect.timePeriod) {
            const key = `${effect.season}_${effect.timePeriod}`;
            if (this.seasonTimePeriodEffects.has(key)) {
              this.seasonTimePeriodEffects.get(key).delete(effectId);
              if (this.seasonTimePeriodEffects.get(key).size === 0) {
                this.seasonTimePeriodEffects.delete(key);
              }
            }
          }
          this.effects.delete(effectId);
          this.originalWeights.delete(effectId); // 从原始比重映射中移除
        }
        return this;
      }
    
      /**
       * 重置所有效果的比重到原始值
       */
      resetWeightsToOriginal() {
        for (const [effectId, originalWeight] of this.originalWeights.entries()) {
          const effect = this.effects.get(effectId);
          if (effect) {
            this.updateWeight(effectId, originalWeight);
          }
        }
        this.lastResetDate = new Date().toDateString();
        console.log('效果比重已重置到原始值');
        return this;
      }
    
      /**
       * 检查并执行每日重置
       */
      checkAndResetDaily() {
        const today = new Date().toDateString();
        if (this.lastResetDate !== today) {
          this.resetWeightsToOriginal();
        }
        return this;
      }
    
      /**
       * 获取效果的原始比重
       * @param {string} effectId - 效果ID
       */
      getOriginalWeight(effectId) {
        return this.originalWeights.get(effectId);
      }
    
      /**
       * 更新效果比重
       * @param {string} effectId - 效果ID
       * @param {number} weight - 新的比重
       */
      
      updateWeight(effectId, weight) {
        if (!this.effects.has(effectId)) {
          throw new Error(`效果 ${effectId} 不存在`);
        }
    
        if (typeof weight !== 'number' || weight < 0 || weight > 100) {
          throw new Error('比重必须是0-100之间的数字');
        }
    
        const oldEffect = this.effects.get(effectId);
        const updatedEffect = {
          ...oldEffect,
          weight: weight
        };
    
        this.effects.set(effectId, updatedEffect);
    
        // 更新季节分组中的效果
        if (oldEffect.season && this.seasonEffects.has(oldEffect.season)) {
          this.seasonEffects.get(oldEffect.season).set(effectId, updatedEffect);
        }
    
        // 更新时段分组中的效果
        if (oldEffect.timePeriod && this.timePeriodEffects.has(oldEffect.timePeriod)) {
          this.timePeriodEffects.get(oldEffect.timePeriod).set(effectId, updatedEffect);
        }
    
        // 更新季节+时段分组中的效果
        if (oldEffect.season && oldEffect.timePeriod) {
          const key = `${oldEffect.season}_${oldEffect.timePeriod}`;
          if (this.seasonTimePeriodEffects.has(key)) {
            this.seasonTimePeriodEffects.get(key).set(effectId, updatedEffect);
          }
        }
    
        return this;
      }
    
      /**
       * 获取效果
       * @param {string} effectId - 效果ID
       */
      getEffect(effectId) {
        return this.effects.get(effectId);
      }
    
      /**
       * 获取所有效果
       */
      getAllEffects() {
        return Array.from(this.effects.values());
      }
    
      /**
       * 根据时间解析结果获取效果
       * @param {Object} timeInfo - 时间解析结果
       */
      getEffectsByTimeInfo(timeInfo) {
        const season = timeInfo.season ? timeInfo.season.name : null;
        const timePeriod = timeInfo.timePeriod ? timeInfo.timePeriod.name : null;
    
        // 如果没有季节或时段信息，返回空数组
        if (!season || !timePeriod) {
          return [];
        }
    
        // 尝试获取同时匹配季节和时段的效果
        const key = `${season}_${timePeriod}`;
        if (this.seasonTimePeriodEffects.has(key)) {
          return Array.from(this.seasonTimePeriodEffects.get(key).values());
        }
    
        return [];
      }
    
      /**
       * 获取指定季节的效果
       * @param {string} season - 季节
       */
      getEffectsBySeason(season) {
        if (!this.seasonEffects.has(season)) {
          return [];
        }
        return Array.from(this.seasonEffects.get(season).values());
      }
    
      /**
       * 获取指定时段的效果
       * @param {string} timePeriod - 时段
       */
      getEffectsByTimePeriod(timePeriod) {
        if (!this.timePeriodEffects.has(timePeriod)) {
          return [];
        }
        return Array.from(this.timePeriodEffects.get(timePeriod).values());
      }
    
      /**
       * 根据比重随机选择一个效果
       * @param {Array} effects - 效果列表，如果不提供则使用所有效果
       * @param {boolean} considerOccurrences - 是否考虑出现次数来调整权重
       */
      getRandomEffectByWeight(effects = null, considerOccurrences = true) {
        const effectList = effects || this.getAllEffects();
        if (effectList.length === 0) {
          return null;
        }
    
        // 过滤掉权重为0的效果
        const validEffects = effectList.filter(effect => effect.weight > 0);
        if (validEffects.length === 0) {
          return null;
        }
    
        // 计算总比重
        const totalWeight = validEffects.reduce((sum, effect) => sum + effect.weight, 0);
        if (totalWeight === 0) {
          // 如果总比重为0，随机选择
          return validEffects[Math.floor(Math.random() * validEffects.length)];
        }
    
        // 生成随机数
        let random = Math.random() * totalWeight;
    
        // 根据比重选择效果
        for (const effect of validEffects) {
          random -= effect.weight;
          if (random <= 0) {
            return effect;
          }
        }
    
        // 以防万一，返回最后一个效果
        return validEffects[validEffects.length - 1];
      }
    
      /**
       * 根据时间解析结果和比重随机选择一个效果
       * @param {Object} timeInfo - 时间解析结果
       */
      getRandomEffectByTimeInfo(timeInfo) {
        const seasonTimePeriodEffects = this.getEffectsByTimeInfo(timeInfo);
        return this.getRandomEffectByWeight(seasonTimePeriodEffects, true);
      }
    
      /**
       * 检查是否存在指定效果
       * @param {string} effectId - 效果ID
       */
      hasEffect(effectId) {
        return this.effects.has(effectId);
      }
    
      /**
       * 清空所有效果
       */
      clearAllEffects() {
        this.effects.clear();
        this.seasonEffects.clear();
        this.timePeriodEffects.clear();
        this.seasonTimePeriodEffects.clear();
        this.originalWeights.clear();
        this.lastResetDate = null;
        return this;
      }
    
      /**
       * 获取比重统计信息
       */
      getWeightStats() {
        const stats = {
          totalEffects: this.effects.size,
          seasonDistribution: {},
          totalWeight: 0
        };
    
        if (this.effects.size > 0) {
          stats.totalWeight = Array.from(this.effects.values()).reduce((sum, effect) => sum + effect.weight, 0);
    
          // 按季节统计
          for (const [season, effects] of this.seasonEffects.entries()) {
            stats.seasonDistribution[season] = {
              count: effects.size,
              totalWeight: Array.from(effects.values()).reduce((sum, effect) => sum + effect.weight, 0)
            };
          }
        }
    
        return stats;
      }
    }
    
    // 导出单例实例
    const weightManager = new WeightManager();
    exports.default = weightManager;
    exports.WeightManager = WeightManager;;
  };

  // 模块: ../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/local_time_parser
  __modules["../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/local_time_parser"] = function(module, exports, __require) {
    /**
     * 本地时间解析模块
     * 负责解析本地时间，提供时间相关的基础功能
     */
    
    class LocalTimeParser {
      /**
       * 获取当前本地时间
       * @returns {Date} 当前本地时间对象
       */
      getCurrentTime() {
        return new Date();
      }
    
      /**
       * 获取时间的各个部分
       * @param {Date} date - 可选的日期对象，默认使用当前时间
       * @returns {Object} 包含时间各个部分的对象
       */
      getTimeComponents(date = new Date()) {
        return {
          year: date.getFullYear(),
          month: date.getMonth() + 1, // 月份从0开始，所以+1
          day: date.getDate(),
          hour: date.getHours(),
          minute: date.getMinutes(),
          second: date.getSeconds(),
          millisecond: date.getMilliseconds(),
          dayOfWeek: date.getDay() // 0-6，0表示星期日
        };
      }
    
      /**
       * 格式化时间
       * @param {Date} date - 可选的日期对象，默认使用当前时间
       * @param {string} format - 格式化字符串，默认 'YYYY-MM-DD HH:mm:ss'
       * @returns {string} 格式化后的时间字符串
       */
      formatTime(date = new Date(), format = 'YYYY-MM-DD HH:mm:ss') {
        const components = this.getTimeComponents(date);
        
        return format
          .replace('YYYY', components.year)
          .replace('MM', String(components.month).padStart(2, '0'))
          .replace('DD', String(components.day).padStart(2, '0'))
          .replace('HH', String(components.hour).padStart(2, '0'))
          .replace('mm', String(components.minute).padStart(2, '0'))
          .replace('ss', String(components.second).padStart(2, '0'));
      }
    
      /**
       * 获取时间戳
       * @param {Date} date - 可选的日期对象，默认使用当前时间
       * @returns {number} 时间戳（毫秒）
       */
      getTimestamp(date = new Date()) {
        return date.getTime();
      }
    
      /**
       * 从时间戳创建日期对象
       * @param {number} timestamp - 时间戳（毫秒）
       * @returns {Date} 日期对象
       */
      fromTimestamp(timestamp) {
        return new Date(timestamp);
      }
    }
    
    module.exports = new LocalTimeParser();
  };

  // 模块: ../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/effect_scheduler/effect_scheduler
  __modules["../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/effect_scheduler/effect_scheduler"] = function(module, exports, __require) {
    /**
     * 效果调度器
     * 用于根据比重调度和执行四季系统的效果
     */
    var weightManager = __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/effect_scheduler/priority_manager").default || __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/effect_scheduler/priority_manager");;
    
    class EffectScheduler {
      constructor() {
        this.runningEffects = new Set();
        this.effectHandlers = new Map();
        this.maxConcurrentEffects = 10;
      }
    
      /**
       * 注册效果处理器
       * @param {string} effectType - 效果类型
       * @param {Function} handler - 效果处理函数
       */
      registerEffectHandler(effectType, handler) {
        if (typeof handler !== 'function') {
          throw new Error('效果处理器必须是函数');
        }
        this.effectHandlers.set(effectType, handler);
        return this;
      }
    
      /**
       * 移除效果处理器
       * @param {string} effectType - 效果类型
       */
      removeEffectHandler(effectType) {
        this.effectHandlers.delete(effectType);
        return this;
      }
    
      /**
       * 获取效果处理器
       * @param {string} effectType - 效果类型
       */
      getEffectHandler(effectType) {
        return this.effectHandlers.get(effectType);
      }
    
      /**
       * 添加效果
       * @param {string} effectId - 效果ID
       * @param {Object} effectConfig - 效果配置
       * @param {number} weight - 比重
       * @param {string} season - 季节
       * @param {string} timePeriod - 时段
       */
      addEffect(effectId, effectConfig, weight, season = null, timePeriod = null) {
        weightManager.addEffect(effectId, effectConfig, weight, season, timePeriod);
        return this;
      }
    
      /**
       * 移除效果
       * @param {string} effectId - 效果ID
       */
      removeEffect(effectId) {
        if (this.runningEffects.has(effectId)) {
          this.stopEffect(effectId);
        }
        weightManager.removeEffect(effectId);
        return this;
      }
    
      /**
       * 更新效果比重
       * @param {string} effectId - 效果ID
       * @param {number} weight - 新的比重
       */
      updateEffectWeight(effectId, weight) {
        weightManager.updateWeight(effectId, weight);
        return this;
      }
    
      /**
       * 执行效果
       * @param {string} effectId - 效果ID
       */
      async executeEffect(effectId) {
        // 检查并执行每日重置
        weightManager.checkAndResetDaily();
    
        const effect = weightManager.getEffect(effectId);
        if (!effect) {
          throw new Error(`效果 ${effectId} 不存在`);
        }
    
        const { type } = effect.config;
        const handler = this.getEffectHandler(type);
        if (!handler) {
          throw new Error(`未注册效果类型 ${type} 的处理器`);
        }
    
        if (this.runningEffects.has(effectId)) {
          console.warn(`效果 ${effectId} 已经在运行中`);
          return;
        }
    
        if (this.runningEffects.size >= this.maxConcurrentEffects) {
          console.warn('达到最大并发效果数量，等待执行');
          // 可以实现队列机制，这里简化处理
          return;
        }
    
        this.runningEffects.add(effectId);
    
        try {
          console.log(`开始执行效果: ${effectId} (比重: ${effect.weight})`);
          await handler(effect.config);
          console.log(`效果执行完成: ${effectId}`);
    
          // 执行完成后，将该效果的比重下降5%
          const newWeight = Math.max(0, effect.weight * 0.95);
          weightManager.updateWeight(effectId, newWeight);
          console.log(`效果 ${effectId} 比重已调整为: ${newWeight.toFixed(1)}`);
        } catch (error) {
          console.error(`效果执行出错: ${effectId}`, error);
        } finally {
          this.runningEffects.delete(effectId);
        }
      }
    
      /**
       * 停止效果
       * @param {string} effectId - 效果ID
       */
      stopEffect(effectId) {
        // 这里可以添加具体的效果停止逻辑
        // 例如取消动画、清除定时器等
        this.runningEffects.delete(effectId);
        console.log(`效果已停止: ${effectId}`);
        return this;
      }
    
      /**
       * 执行所有效果
       */
      async executeAllEffects() {
        const effects = weightManager.getAllEffects();
        for (const effect of effects) {
          await this.executeEffect(effect.id);
        }
      }
    
      /**
       * 执行指定季节的效果
       * @param {string} season - 季节
       */
      async executeEffectsBySeason(season) {
        const effects = weightManager.getEffectsBySeason(season);
        for (const effect of effects) {
          await this.executeEffect(effect.id);
        }
      }
    
      /**
       * 根据时间解析结果执行效果
       * @param {Object} timeInfo - 时间解析结果
       */
      async executeEffectsByTimeInfo(timeInfo) {
        const effects = weightManager.getEffectsByTimeInfo(timeInfo);
        for (const effect of effects) {
          await this.executeEffect(effect.id);
        }
      }
    
      /**
       * 随机执行一个效果（根据比重）
       * @param {Object} timeInfo - 时间解析结果，如果提供则只从对应季节的效果中选择
       */
      async executeRandomEffect(timeInfo = null) {
        let effect;
        if (timeInfo) {
          effect = weightManager.getRandomEffectByTimeInfo(timeInfo);
        } else {
          effect = weightManager.getRandomEffectByWeight();
        }
    
        if (effect) {
          await this.executeEffect(effect.id);
        }
        return effect;
      }
    
      /**
       * 获取运行中的效果
       */
      getRunningEffects() {
        return Array.from(this.runningEffects);
      }
    
      /**
       * 获取效果统计信息
       */
      getStats() {
        const weightStats = weightManager.getWeightStats();
        return {
          ...weightStats,
          runningEffects: this.runningEffects.size,
          registeredHandlers: this.effectHandlers.size,
          maxConcurrentEffects: this.maxConcurrentEffects
        };
      }
    
      /**
       * 设置最大并发效果数量
       * @param {number} max - 最大并发数量
       */
      setMaxConcurrentEffects(max) {
        if (typeof max !== 'number' || max <= 0) {
          throw new Error('最大并发数量必须是正整数');
        }
        this.maxConcurrentEffects = max;
        return this;
      }
    
      /**
       * 清空所有效果
       */
      clearAllEffects() {
        // 停止所有运行中的效果
        for (const effectId of this.runningEffects) {
          this.stopEffect(effectId);
        }
        weightManager.clearAllEffects();
        return this;
      }
    }
    
    // 导出单例实例
    const effectScheduler = new EffectScheduler();
    exports.default = effectScheduler;
    exports.EffectScheduler = EffectScheduler;;
  };

  // 模块: ../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/season_determination
  __modules["../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/season_determination"] = function(module, exports, __require) {
    /**
     * 季节判定逻辑模块
     * 负责根据日期判定当前季节
     */
    
    var __imported__________D__WorkSpace_IIS_static_source_js_season_system_season_manager_time_detection_local_time_parser = __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/local_time_parser").default || __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/local_time_parser");
    var getTimeComponents = function() { return __imported__________D__WorkSpace_IIS_static_source_js_season_system_season_manager_time_detection_local_time_parser.getTimeComponents.apply(__imported__________D__WorkSpace_IIS_static_source_js_season_system_season_manager_time_detection_local_time_parser, arguments); };;
    
    class SeasonDetermination {
      /**
       * 季节常量
       */
      static SEASONS = {
        SPRING: 'spring',
        SUMMER: 'summer',
        AUTUMN: 'autumn',
        WINTER: 'winter'
      };
    
      /**
       * 获取当前季节
       * @param {Date} date - 可选的日期对象，默认使用当前时间
       * @returns {string} 当前季节的英文名称
       */
      getCurrentSeason(date = new Date()) {
        const components = getTimeComponents(date);
        const month = components.month;
        const day = components.day;
    
        // 根据月份和日期判断季节
        // 春季：3月21日 - 6月20日
        // 夏季：6月21日 - 9月22日
        // 秋季：9月23日 - 12月20日
        // 冬季：12月21日 - 3月20日
        
        if ((month === 3 && day >= 21) || (month === 4) || (month === 5) || (month === 6 && day <= 20)) {
          return SeasonDetermination.SEASONS.SPRING;
        } else if ((month === 6 && day >= 21) || (month === 7) || (month === 8) || (month === 9 && day <= 22)) {
          return SeasonDetermination.SEASONS.SUMMER;
        } else if ((month === 9 && day >= 23) || (month === 10) || (month === 11) || (month === 12 && day <= 20)) {
          return SeasonDetermination.SEASONS.AUTUMN;
        } else {
          return SeasonDetermination.SEASONS.WINTER;
        }
      }
    
      /**
       * 获取季节的中文名称
       * @param {string} season - 季节的英文名称
       * @returns {string} 季节的中文名称
       */
      getSeasonChineseName(season) {
        const seasonMap = {
          [SeasonDetermination.SEASONS.SPRING]: '春季',
          [SeasonDetermination.SEASONS.SUMMER]: '夏季',
          [SeasonDetermination.SEASONS.AUTUMN]: '秋季',
          [SeasonDetermination.SEASONS.WINTER]: '冬季'
        };
    
        return seasonMap[season] || season;
      }
    
      /**
       * 获取季节的开始和结束日期
       * @param {string} season - 季节的英文名称
       * @param {number} year - 年份，默认使用当前年份
       * @returns {Object} 包含开始和结束日期的对象
       */
      getSeasonDateRange(season, year = new Date().getFullYear()) {
        const ranges = {
          [SeasonDetermination.SEASONS.SPRING]: {
            start: new Date(year, 2, 21), // 3月21日
            end: new Date(year, 5, 20)    // 6月20日
          },
          [SeasonDetermination.SEASONS.SUMMER]: {
            start: new Date(year, 5, 21), // 6月21日
            end: new Date(year, 8, 22)    // 9月22日
          },
          [SeasonDetermination.SEASONS.AUTUMN]: {
            start: new Date(year, 8, 23), // 9月23日
            end: new Date(year, 11, 20)   // 12月20日
          },
          [SeasonDetermination.SEASONS.WINTER]: {
            start: new Date(year, 11, 21), // 12月21日
            end: new Date(year + 1, 2, 20) // 次年3月20日
          }
        };
    
        return ranges[season] || null;
      }
    
      /**
       * 检查给定日期是否在指定季节内
       * @param {Date} date - 日期对象
       * @param {string} season - 季节的英文名称
       * @returns {boolean} 是否在指定季节内
       */
      isDateInSeason(date, season) {
        const targetSeason = this.getCurrentSeason(date);
        return targetSeason === season;
      }
    }
    
    exports.default = new SeasonDetermination();
  };

  // 模块: ../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/time_period_identifier
  __modules["../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/time_period_identifier"] = function(module, exports, __require) {
    /**
     * 时段识别模块
     * 负责识别一天中的时段（晨/午/晚/夜）
     */
    
    var __imported__________D__WorkSpace_IIS_static_source_js_season_system_season_manager_time_detection_local_time_parser = __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/local_time_parser").default || __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/local_time_parser");
    var getTimeComponents = function() { return __imported__________D__WorkSpace_IIS_static_source_js_season_system_season_manager_time_detection_local_time_parser.getTimeComponents.apply(__imported__________D__WorkSpace_IIS_static_source_js_season_system_season_manager_time_detection_local_time_parser, arguments); };;
    
    class TimePeriodIdentifier {
      /**
       * 时段常量
       */
      static TIME_PERIODS = {
        MORNING: 'morning',      // 早晨
        AFTERNOON: 'afternoon',  // 下午
        EVENING: 'evening',      // 晚上
        NIGHT: 'night'           // 夜晚
      };
    
      /**
       * 获取当前时段
       * @param {Date} date - 可选的日期对象，默认使用当前时间
       * @returns {string} 当前时段的英文名称
       */
      getCurrentTimePeriod(date = new Date()) {
        const components = getTimeComponents(date);
        const hour = components.hour;
    
        // 根据小时判断时段
        // 早晨：6:00 - 12:00
        // 下午：12:00 - 18:00
        // 晚上：18:00 - 22:00
        // 夜晚：22:00 - 6:00
        
        if (hour >= 6 && hour < 12) {
          return TimePeriodIdentifier.TIME_PERIODS.MORNING;
        } else if (hour >= 12 && hour < 18) {
          return TimePeriodIdentifier.TIME_PERIODS.AFTERNOON;
        } else if (hour >= 18 && hour < 22) {
          return TimePeriodIdentifier.TIME_PERIODS.EVENING;
        } else {
          return TimePeriodIdentifier.TIME_PERIODS.NIGHT;
        }
      }
    
      /**
       * 获取时段的中文名称
       * @param {string} timePeriod - 时段的英文名称
       * @returns {string} 时段的中文名称
       */
      getTimePeriodChineseName(timePeriod) {
        const periodMap = {
          [TimePeriodIdentifier.TIME_PERIODS.MORNING]: '早晨',
          [TimePeriodIdentifier.TIME_PERIODS.AFTERNOON]: '下午',
          [TimePeriodIdentifier.TIME_PERIODS.EVENING]: '晚上',
          [TimePeriodIdentifier.TIME_PERIODS.NIGHT]: '夜晚'
        };
    
        return periodMap[timePeriod] || timePeriod;
      }
    
      /**
       * 获取时段的开始和结束时间
       * @param {string} timePeriod - 时段的英文名称
       * @returns {Object} 包含开始和结束小时的对象
       */
      getTimePeriodRange(timePeriod) {
        const ranges = {
          [TimePeriodIdentifier.TIME_PERIODS.MORNING]: {
            start: 6,
            end: 12
          },
          [TimePeriodIdentifier.TIME_PERIODS.AFTERNOON]: {
            start: 12,
            end: 18
          },
          [TimePeriodIdentifier.TIME_PERIODS.EVENING]: {
            start: 18,
            end: 22
          },
          [TimePeriodIdentifier.TIME_PERIODS.NIGHT]: {
            start: 22,
            end: 6
          }
        };
    
        return ranges[timePeriod] || null;
      }
    
      /**
       * 检查给定时间是否在指定时段内
       * @param {Date} date - 日期对象
       * @param {string} timePeriod - 时段的英文名称
       * @returns {boolean} 是否在指定时段内
       */
      isTimeInPeriod(date, timePeriod) {
        const targetPeriod = this.getCurrentTimePeriod(date);
        return targetPeriod === timePeriod;
      }
    
      /**
       * 获取下一个时段
       * @param {string} currentPeriod - 当前时段的英文名称
       * @returns {string} 下一个时段的英文名称
       */
      getNextTimePeriod(currentPeriod) {
        const periodOrder = [
          TimePeriodIdentifier.TIME_PERIODS.MORNING,
          TimePeriodIdentifier.TIME_PERIODS.AFTERNOON,
          TimePeriodIdentifier.TIME_PERIODS.EVENING,
          TimePeriodIdentifier.TIME_PERIODS.NIGHT
        ];
    
        const currentIndex = periodOrder.indexOf(currentPeriod);
        if (currentIndex === -1) {
          return null;
        }
    
        const nextIndex = (currentIndex + 1) % periodOrder.length;
        return periodOrder[nextIndex];
      }
    }
    
    exports.default = new TimePeriodIdentifier();
  };

  // 模块: ../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/time_detection
  __modules["../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/time_detection"] = function(module, exports, __require) {
    /**
     * 时间检测模块主入口
     * 整合本地时间解析、季节判定和时段识别功能
     */
    
    var localTimeParser = __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/local_time_parser").default || __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/local_time_parser");
    var getTimeComponents = function() { return localTimeParser.getTimeComponents.apply(localTimeParser, arguments); };
    var formatTime = function() { return localTimeParser.formatTime.apply(localTimeParser, arguments); };;
    var seasonDetermination = __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/season_determination").default || __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/season_determination");
    var getCurrentSeason = function() { return seasonDetermination.getCurrentSeason.apply(seasonDetermination, arguments); };
    var getSeasonChineseName = function() { return seasonDetermination.getSeasonChineseName.apply(seasonDetermination, arguments); };
    var getSeasonDateRange = function() { return seasonDetermination.getSeasonDateRange.apply(seasonDetermination, arguments); };
    var isDateInSeason = function() { return seasonDetermination.isDateInSeason.apply(seasonDetermination, arguments); };;
    var timePeriodIdentifier = __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/time_period_identifier").default || __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/time_period_identifier");
    var getCurrentTimePeriod = function() { return timePeriodIdentifier.getCurrentTimePeriod.apply(timePeriodIdentifier, arguments); };
    var getTimePeriodChineseName = function() { return timePeriodIdentifier.getTimePeriodChineseName.apply(timePeriodIdentifier, arguments); };
    var getTimePeriodRange = function() { return timePeriodIdentifier.getTimePeriodRange.apply(timePeriodIdentifier, arguments); };
    var isTimeInPeriod = function() { return timePeriodIdentifier.isTimeInPeriod.apply(timePeriodIdentifier, arguments); };;
    
    class TimeDetection {
      /**
       * 获取本地时间解析器
       * @returns {Object} 本地时间解析器实例
       */
      getLocalTimeParser() {
        return localTimeParser;
      }
    
      /**
       * 获取季节判定器
       * @returns {Object} 季节判定器实例
       */
      getSeasonDetermination() {
        return seasonDetermination;
      }
    
      /**
       * 获取时段识别器
       * @returns {Object} 时段识别器实例
       */
      getTimePeriodIdentifier() {
        return timePeriodIdentifier;
      }
    
      /**
       * 获取当前时间信息
       * @param {Date} date - 可选的日期对象，默认使用当前时间
       * @returns {Object} 包含时间、季节和时段信息的对象
       */
      getCurrentTimeInfo(date = new Date()) {
        const timeComponents = getTimeComponents(date);
        const season = getCurrentSeason(date);
        const timePeriod = getCurrentTimePeriod(date);
    
        return {
          time: date,
          components: timeComponents,
          season: {
            name: season,
            chineseName: getSeasonChineseName(season),
            range: getSeasonDateRange(season, timeComponents.year)
          },
          timePeriod: {
            name: timePeriod,
            chineseName: getTimePeriodChineseName(timePeriod),
            range: getTimePeriodRange(timePeriod)
          },
          formattedTime: formatTime(date)
        };
      }
    
      /**
       * 检查是否为特定季节
       * @param {string} season - 季节的英文名称
       * @param {Date} date - 可选的日期对象，默认使用当前时间
       * @returns {boolean} 是否为特定季节
       */
      isSeason(season, date = new Date()) {
        return isDateInSeason(date, season);
      }
    
      /**
       * 检查是否为特定时段
       * @param {string} timePeriod - 时段的英文名称
       * @param {Date} date - 可选的日期对象，默认使用当前时间
       * @returns {boolean} 是否为特定时段
       */
      isTimePeriod(timePeriod, date = new Date()) {
        return isTimeInPeriod(date, timePeriod);
      }
    
      /**
       * 获取时间检测的所有常量
       * @returns {Object} 包含所有常量的对象
       */
      getConstants() {
        return {
          seasons: seasonDetermination.constructor.SEASONS,
          timePeriods: timePeriodIdentifier.constructor.TIME_PERIODS
        };
      }
    }
    
    exports.default = new TimeDetection();
  };

  // 模块: ../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_manager
  __modules["../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_manager"] = function(module, exports, __require) {
    /**
     * 时间管理器
     * 作为上层模块调用时间检测模块中的功能，并提供定时任务和时间监听等高级功能
     */
    
    var timeDetection = __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/time_detection").default || __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/time_detection");;
    
    class TimeManager {
      constructor() {
        this.timeDetection = timeDetection;
        this.timers = new Map(); // 存储定时任务
        this.listeners = new Map(); // 存储时间监听器
        this.lastTimeInfo = null; // 上次的时间信息
      }
    
      /**
       * 获取当前时间信息
       * @returns {Object} 包含时间、季节和时段信息的对象
       */
      getCurrentTimeInfo() {
        const timeInfo = this.timeDetection.getCurrentTimeInfo();
        return timeInfo;
      }
    
      /**
       * 获取时间检测模块
       * @returns {Object} 时间检测模块实例
       */
      getTimeDetection() {
        return this.timeDetection;
      }
    
      /**
       * 执行定时任务
       * @param {string} taskName - 任务名称
       * @param {Function} callback - 回调函数
       * @param {number} delay - 延迟时间（毫秒）
       * @returns {string} 任务ID
       */
      setTimeout(taskName, callback, delay) {
        const timerId = setTimeout(() => {
          callback();
          this.timers.delete(taskName);
        }, delay);
    
        this.timers.set(taskName, timerId);
        return taskName;
      }
    
      /**
       * 执行重复定时任务
       * @param {string} taskName - 任务名称
       * @param {Function} callback - 回调函数
       * @param {number} interval - 间隔时间（毫秒）
       * @returns {string} 任务ID
       */
      setInterval(taskName, callback, interval) {
        const timerId = setInterval(callback, interval);
        this.timers.set(taskName, timerId);
        return taskName;
      }
    
      /**
       * 清除定时任务
       * @param {string} taskName - 任务名称
       * @returns {boolean} 是否成功清除
       */
      clearTimer(taskName) {
        const timerId = this.timers.get(taskName);
        if (timerId) {
          clearTimeout(timerId);
          clearInterval(timerId);
          this.timers.delete(taskName);
          return true;
        }
        return false;
      }
    
      /**
       * 清除所有定时任务
       */
      clearAllTimers() {
        for (const [taskName, timerId] of this.timers) {
          clearTimeout(timerId);
          clearInterval(timerId);
        }
        this.timers.clear();
      }
    
      /**
       * 添加时间监听器
       * @param {string} eventType - 事件类型（seasonChange, timePeriodChange, minuteChange等）
       * @param {Function} callback - 回调函数
       * @returns {string} 监听器ID
       */
      addListener(eventType, callback) {
        if (!this.listeners.has(eventType)) {
          this.listeners.set(eventType, new Map());
        }
    
        const listenerId = `${eventType}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        this.listeners.get(eventType).set(listenerId, callback);
    
        return listenerId;
      }
    
      /**
       * 移除时间监听器
       * @param {string} eventType - 事件类型
       * @param {string} listenerId - 监听器ID
       * @returns {boolean} 是否成功移除
       */
      removeListener(eventType, listenerId) {
        if (this.listeners.has(eventType)) {
          const eventListeners = this.listeners.get(eventType);
          if (eventListeners.has(listenerId)) {
            eventListeners.delete(listenerId);
            return true;
          }
        }
        return false;
      }
    
      /**
       * 移除所有指定类型的监听器
       * @param {string} eventType - 事件类型
       */
      removeAllListeners(eventType) {
        if (this.listeners.has(eventType)) {
          this.listeners.get(eventType).clear();
        }
      }
    
      /**
       * 触发时间事件
       * @param {string} eventType - 事件类型
       * @param {Object} eventData - 事件数据
       */
      emit(eventType, eventData) {
        if (this.listeners.has(eventType)) {
          const eventListeners = this.listeners.get(eventType);
          for (const callback of eventListeners.values()) {
            callback(eventData);
          }
        }
      }
    
      /**
       * 启动时间监控
       * @param {number} interval - 监控间隔（毫秒），默认1000ms
       */
      startMonitoring(interval = 1000) {
        this.setInterval('timeMonitoring', () => {
          const currentTimeInfo = this.getCurrentTimeInfo();
    
          // 检查季节变化
          if (this.lastTimeInfo && this.lastTimeInfo.season.name !== currentTimeInfo.season.name) {
            this.emit('seasonChange', {
              oldSeason: this.lastTimeInfo.season,
              newSeason: currentTimeInfo.season,
              timeInfo: currentTimeInfo
            });
          }
    
          // 检查时段变化
          if (this.lastTimeInfo && this.lastTimeInfo.timePeriod.name !== currentTimeInfo.timePeriod.name) {
            this.emit('timePeriodChange', {
              oldTimePeriod: this.lastTimeInfo.timePeriod,
              newTimePeriod: currentTimeInfo.timePeriod,
              timeInfo: currentTimeInfo
            });
          }
    
          // 检查分钟变化
          if (!this.lastTimeInfo || this.lastTimeInfo.components.minute !== currentTimeInfo.components.minute) {
            this.emit('minuteChange', {
              timeInfo: currentTimeInfo
            });
          }
    
          // 检查小时变化
          if (!this.lastTimeInfo || this.lastTimeInfo.components.hour !== currentTimeInfo.components.hour) {
            this.emit('hourChange', {
              timeInfo: currentTimeInfo
            });
          }
    
          // 检查日期变化
          if (!this.lastTimeInfo || this.lastTimeInfo.components.day !== currentTimeInfo.components.day) {
            this.emit('dayChange', {
              timeInfo: currentTimeInfo
            });
          }
          this.lastTimeInfo = currentTimeInfo;
        }, interval);
      }
    
      /**
       * 停止时间监控
       */
      stopMonitoring() {
        this.clearTimer('timeMonitoring');
      }
    
      /**
       * 获取所有定时任务
       * @returns {Array} 定时任务列表
       */
      getAllTimers() {
        return Array.from(this.timers.keys());
      }
    
      /**
       * 获取所有监听器
       * @returns {Object} 监听器列表
       */
      getAllListeners() {
        const result = {};
        for (const [eventType, eventListeners] of this.listeners) {
          result[eventType] = Array.from(eventListeners.keys());
        }
        return result;
      }
    
      /**
       * 销毁时间管理器
       */
      destroy() {
        this.clearAllTimers();
        this.listeners.clear();
        this.lastTimeInfo = null;
      }
    }
    
    exports.default = new TimeManager();
  };

  // 模块: ../../../D:/WorkSpace/IIS/static/source/js/season_system/manager
  __modules["../../../D:/WorkSpace/IIS/static/source/js/season_system/manager"] = function(module, exports, __require) {
    /**
     * 四季系统主入口文件
     * 提供系统核心功能的统一访问接口
     */
    
    // 引入时间管理器
    var timeManager = __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_manager").default || __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_manager");;
    
    // 引入时间检测模块
    var timeDetection = __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/time_detection").default || __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/time_detection/time_detection");;
    
    /**
     * 效果调度器模块入口
     * 导出效果比重管理相关的组件
     */
    var weightManager = __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/effect_scheduler/priority_manager").default || __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/effect_scheduler/priority_manager");;
    var effectScheduler = __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/effect_scheduler/effect_scheduler").default || __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/season_manager/effect_scheduler/effect_scheduler");;
    
    /**
     * 效果库模块
     */
    // 引入效果库模块
    var flowerEffect = __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/spring/floawer").default || __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/spring/floawer");;
    var winterNightEffect = __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/winter/night_effect").default || __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/winter/night_effect");;
    var starEffect = __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/winter/star_effect").default || __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/winter/star_effect");;
    var lightEffect = __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/winter/light_effect").default || __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/winter/light_effect");;
    var winterDayEffect = __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/winter/day_effect").default || __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/effects_library/winter/day_effect");;
    
    /**
     * 四季系统主类
     */
    class SeasonSystem {
      /**
       * 构造函数
       */
      constructor() {
        this.timeManager = timeManager;
        this.timeDetection = timeDetection;
        this.weightManager = weightManager;
        this.effectScheduler = effectScheduler;
        this.effects = {
          flower: flowerEffect,
          winterNight: winterNightEffect,
          star: starEffect,
          light: lightEffect,
          winterDay: winterDayEffect
        };
        this.isMonitoringStarted = false;
       }
    
      /**
       * 获取时间管理器
       * @returns {Object} 时间管理器实例
       */
      getTimeManager() {
        return this.timeManager;
      }
    
      /**
       * 获取时间检测模块
       * @returns {Object} 时间检测模块实例
       */
      getTimeDetection() {
        return this.timeDetection;
      }
    
      /**
       * 获取当前时间信息
       * @returns {Object} 包含时间、季节和时段信息的对象
       */
      getCurrentTimeInfo() {
        return this.timeManager.getCurrentTimeInfo();
      }
    
      /**
       * 启动时间监控
       * @param {number} interval - 监控间隔（毫秒），默认1000ms
       */
      startTimeMonitoring(interval = 1000) {
        if (!this.isMonitoringStarted) {
          this.timeManager.startMonitoring(interval);
          this.isMonitoringStarted = true;
          console.log('四季系统：时间监控已启动');
        }
      }
    
      /**
       * 停止时间监控
       */
      stopTimeMonitoring() {
        if (this.isMonitoringStarted) {
          this.timeManager.stopMonitoring();
          this.isMonitoringStarted = false;
          console.log('四季系统：时间监控已停止');
        }
      }
    
      /**
       * 添加时间监听器
       * @param {string} eventType - 事件类型
       * @param {Function} callback - 回调函数
       * @returns {string} 监听器ID
       */
      addTimeListener(eventType, callback) {
        return this.timeManager.addListener(eventType, callback);
      }
    
      /**
       * 移除时间监听器
       * @param {string} eventType - 事件类型
       * @param {string} listenerId - 监听器ID
       * @returns {boolean} 是否成功移除
       */
      removeTimeListener(eventType, listenerId) {
        return this.timeManager.removeListener(eventType, listenerId);
      }
    
      /**
       * 执行定时任务
       * @param {string} taskName - 任务名称
       * @param {Function} callback - 回调函数
       * @param {number} delay - 延迟时间（毫秒）
       * @returns {string} 任务ID
       */
      setTimeout(taskName, callback, delay) {
        return this.timeManager.setTimeout(taskName, callback, delay);
      }
    
      /**
       * 执行重复定时任务
       * @param {string} taskName - 任务名称
       * @param {Function} callback - 回调函数
       * @param {number} interval - 间隔时间（毫秒）
       * @returns {string} 任务ID
       */
      setInterval(taskName, callback, interval) {
        return this.timeManager.setInterval(taskName, callback, interval);
      }
    
      /**
       * 清除定时任务
       * @param {string} taskName - 任务名称
       * @returns {boolean} 是否成功清除
       */
      clearTimer(taskName) {
        return this.timeManager.clearTimer(taskName);
      }
    
      /**
       * 清除所有定时任务
       */
      clearAllTimers() {
        this.timeManager.clearAllTimers();
      }
    
      /**
       * 获取系统状态
       * @returns {Object} 系统状态信息
       */
      getStatus() {
        return {
          isMonitoringStarted: this.isMonitoringStarted,
          currentTimeInfo: this.getCurrentTimeInfo(),
          timers: this.timeManager.getAllTimers(),
          listeners: this.timeManager.getAllListeners()
        };
      }
    
      /**
       * 销毁系统实例
       */
      destroy() {
        this.stopTimeMonitoring();
        this.clearAllTimers();
        console.log('四季系统：实例已销毁');
      }
    
      /**
       * 获取效果库
       * @returns {Object} 效果库对象
       */
      getEffects() {
        return this.effects;
      }
    
      /**
       * 获取指定效果
       * @param {string} effectName - 效果名称
       * @returns {Object} 效果实例
       */
      getEffect(effectName) {
        return this.effects[effectName];
      }
    }
    
    // 创建系统实例
    const seasonSystem = new SeasonSystem();
    
    // 导出系统实例
    exports.default = seasonSystem;
    
    // 导出系统类（用于创建新实例）
    const _SeasonSystem = SeasonSystem;
    exports.SeasonSystem = _SeasonSystem;;
    
    // 导出时间相关模块（方便直接访问）
    const _timeManager = timeManager;
    exports.timeManager = _timeManager;;
    const _timeDetection = timeDetection;
    exports.timeDetection = _timeDetection;;
    
    // 导出效果相关模块（方便直接访问）
    const _weightManager = weightManager;
    exports.weightManager = _weightManager;;
    const _effectScheduler = effectScheduler;
    exports.effectScheduler = _effectScheduler;;
    
    // 导出效果库（方便直接访问）
    const _flowerEffect = flowerEffect;
    exports.flowerEffect = _flowerEffect;;
    const _winterNightEffect = winterNightEffect;
    exports.winterNightEffect = _winterNightEffect;;
    const _starEffect = starEffect;
    exports.starEffect = _starEffect;;
    const _lightEffect = lightEffect;
    exports.lightEffect = _lightEffect;;
    const _winterDayEffect = winterDayEffect;
    exports.winterDayEffect = _winterDayEffect;;
    
    
    // 导出效果库集合
    const effectsLibrary = {
      flower: flowerEffect,
      winterNight: winterNightEffect,
      star: starEffect,
      light: lightEffect,
      winterDay: winterDayEffect
    };
    exports.effectsLibrary = effectsLibrary;
  };

  // 启动应用并导出主模块
  // 检测环境并设置导出对象
  var entryModule = __require("../../../D:/WorkSpace/IIS/static/source/js/season_system/manager");
  var exportValue = entryModule.default || entryModule;
  
  // 根据环境导出
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = exportValue;
  } else if (typeof window !== 'undefined') {
    // 在浏览器环境中，将导出值挂载到 window 对象
    window.Bundle = exportValue;
  } else if (typeof global !== 'undefined') {
    global.Bundle = exportValue;
  }
})();